extends go

snippet strp "convert pointer"
strp := func(s string) *string { return &s }
endsnippet

snippet boolp "convert pointer"
boolp := func(b bool) *bool { return &b }
endsnippet

snippet intp "convert pointer"
intp := func(i int) *int { return &i }
endsnippet

snippet int8p "convert pointer"
int8p := func(i int8) *int8 { return &i }
endsnippet

snippet int32p "convert pointer"
int32p := func(i int32) *int32 { return &i }
endsnippet

snippet int64p "convert pointer"
int64p := func(i64 int64) *int64 { return &i64 }
endsnippet

snippet uintp "convert pointer"
uintp := func(i uint) *uint { return &i }
endsnippet

snippet uint8p "convert pointer"
uint8p := func(i uint8) *uint8 { return &i }
endsnippet

snippet uint16p "convert pointer"
uint16p := func(i uint16) *uint16 { return &i }
endsnippet

snippet uint32p "convert pointer"
uint32p := func(i uint32) *uint32 { return &i }
endsnippet

snippet uint64p "convert pointer"
uint64p := func(i uint64) *uint64 { return &i }
endsnippet

snippet timep "convert pointer"
timep := func(t time.Time) *time.Time { return &t }
endsnippet

snippet iferr "if error"
if err != nil {
	return ${0:${VISUAL}}
}
endsnippet

snippet test "test"

func Test${1:FuncName}(t *testing.T) {
	// setup
	${0:${VISUAL}}
	// execute
	// verification
}
endsnippet

snippet as "stretchr assert snippet"
assert.Equal(t, ${1:tt.want}, ${2:got})
${0:${VISUAL}}
endsnippet

snippet asf "stretchr assert snippet"
assert.Equalf(t, ${1:tt.want}, ${2:got}, "input %v", pretty.Sprint(${3:tt.args}))
${0:${VISUAL}}
endsnippet


snippet casetest "casetest snip"
func Test$1(t *testing.T) {
	type fields struct {
	}
	type args struct {
	}
	testCases := []struct {
		name    string
		fields  fields
		args    args

		want    struct{}
		wantErr bool
	}{
		// TODO
	}

	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T){
		// setup
		${0:${VISUAL}}
		// execute
		// verification
		})
	}
}
endsnippet

snippet mockgen "generate mock"
//go:generate mockgen -destination ./${1:package}mock/${2:filename}.go -package $1mock -source ./$2.go
${0:${VISUAL}}
endsnippet

snippet gomock "gomock"
ctrl := gomock.NewController(t)
defer ctrl.Finish()
mock${1:varname} := ${2:packagename}.NewMock${3:ifname}(ctrl)
${0:${VISUAL}}
endsnippet


snippet prd "print debug"
//DEBUG: print debug
fmt.Printf("#################################### ${1:t} %+v\n", pretty.Sprint($1))
${0:${VISUAL}}
endsnippet

snippet deq "deep equal"
if !reflect.DeepEqual($1,$2) {
	${0:${VISUAL}}
}
endsnippet

snippet ctx "context background"
ctx := context.Background()
${0:${VISUAL}}
endsnippet

snippet cctx "context with cancel"
ctx, cancel := context.WithCancel(ctx)
defer cancel()
${0:${VISUAL}}
endsnippet

snippet gdt "date example"
time.Date(2000, 1, 2, 3, 4, 5, 0, time.UTC)
${0:${VISUAL}}
endsnippet

snippet herr "handle error"
func (d *impl) handleError(err error) error {
	${0:${VISUAL}}
	return err
}
endsnippet

snippet cli "urfave cli snippet"
app := cli.NewApp()
app.Name = "${1:name}"
app.Usage = "${2:useage}"
app.Flags = []cli.Flag{
	cli.StringFlag{
		Name:  "${3:flag}, ${4:f}",
		Usage: "usage",
	},
}
app.Action = func(c *cli.Context) error {
	fmt.Println("Hello friend!")
	return nil
}

err := app.Run(os.Args)
if err != nil {
	log.Fatal(err)
}
endsnippet


snippet enum "go enumer"
//go:generate enumer -type=${1:Type} -transform=${2:kebab|snake} -output=${4:output}_enumer.go -trimprefix=$1 ${3:-text|-json|-sql|-yaml}
type $1 uint8

const (
	_ $1 = iota
	${0:${VISUAL}}
)
endsnippet

snippet errch "err chan"
	errCh :=  make(chan error, 1)
	${0:${VISUAL}}
endsnippet

snippet makech "make chan"
	${1:val}Ch :=  make(chan ${2:string}, ${3:0})
	${0:${VISUAL}}
endsnippet

snippet mainsc "for programming contest"
import (
	"bufio"
	"os"
)

func main() {
	sc := bufio.NewScanner(os.Stdin)
	${0:${VISUAL}}
}

func toI(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		panic(err)
	}
	return i
}
endsnippet

