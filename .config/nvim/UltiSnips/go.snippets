extends go

snippet strp "convert pointer"
strp := func(s string) *string { return &s }
endsnippet

snippet boolp "convert pointer"
boolp := func(b bool) *bool { return &b }
endsnippet

snippet intp "convert pointer"
intp := func(i int) *int { return &i }
endsnippet

snippet int8p "convert pointer"
int8p := func(i int8) *int8 { return &i }
endsnippet

snippet int32p "convert pointer"
int32p := func(i int32) *int32 { return &i }
endsnippet

snippet int64p "convert pointer"
int64p := func(i64 int64) *int64 { return &i64 }
endsnippet

snippet uintp "convert pointer"
uintp := func(i uint) *uint { return &i }
endsnippet

snippet uint8p "convert pointer"
uint8p := func(i uint8) *uint8 { return &i }
endsnippet

snippet uint16p "convert pointer"
uint16p := func(i uint16) *uint16 { return &i }
endsnippet

snippet uint32p "convert pointer"
uint32p := func(i uint32) *uint32 { return &i }
endsnippet

snippet uint64p "convert pointer"
uint64p := func(i uint64) *uint64 { return &i }
endsnippet

snippet timep "convert pointer"
timep := func(t time.Time) *time.Time { return &t }
endsnippet

snippet iferr "if error"
if err != nil {
	return ${0:${VISUAL}}
}
endsnippet

snippet test "test"

func Test${1:FuncName}(t *testing.T) {
	t.Log("Set Up")
	${0:${VISUAL}}

	t.Log("Exercise")

	t.Log("Verification")
}
endsnippet

snippet as "stretchr assert snippet"
assert.Equal(t, ${1:tt.want}, ${2:got})${0:${VISUAL}}
endsnippet

snippet casebench "casetest snip"
func Benchmark$1(b *testing.B) {
	testCases := []struct {
		name string
	}{
		// TODO
	}

	for _, tt := range testCases {
		b.Run(tt.name, func(b *testing.B) {
			${0:${VISUAL}}
			b.ResetTimer()
			for i := 0; i < b.N; i++ {
			}
		})
	}
}
endsnippet

snippet casetest "casetest snip"
func Test$1(t *testing.T) {
	testCases := []struct {
		name string
	}{
		// TODO
	}

	for _, tt := range testCases {
		t.Run(tt.name, func(t *testing.T) {
			t.Log("Set Up")
			${0:${VISUAL}}

			t.Log("Exercise")

			t.Log("Verification")
		})
	}
}
endsnippet


snippet tt "tt snip"
tests := []struct {
	name string
}{
	// TODO
}

for _, tt := range tests {
	t.Run(tt.name, func(t *testing.T) {
		${0:${VISUAL}}
	})
}
endsnippet

snippet mockgen "generate mock"
//go:generate mockgen -destination ./$\{GOPACKAGE\}mock/$\{GOFILE\} -package $\{GOPACKAGE\}mock -source ./$\{GOFILE\}
${0:${VISUAL}}
endsnippet


snippet mocklygen "generate mock"
//go:generate mockery --name=${1:IF} --output $\{GOPACKAGE\}mock --outpkg $\{GOPACKAGE\}mock
${0:${VISUAL}}
endsnippet


snippet gomock "gomock"
ctrl := gomock.NewController(t)
defer ctrl.Finish()
${0:${VISUAL}}
endsnippet


snippet prd "print debug"
//DEBUG: print debug
fmt.Printf("#################################### ${1:t} %+v\n", pretty.Sprint($1))
${0:${VISUAL}}
endsnippet

snippet prt "print output test"
//DEBUG: print test
fmt.Printf("\n\n\n%s ######################## ${1:val} = %+v ##############################\n", func() string { _, f, line, _ := runtime.Caller(0); return fmt.Sprintf("%s:%d:", f, line) }(), $1)
${0:${VISUAL}}
endsnippet

snippet ctx "context background"
ctx := context.Background()${0:${VISUAL}}
endsnippet

snippet cctx "context with cancel"
ctx, cancel := context.WithCancel(ctx)
defer cancel()${0:${VISUAL}}
endsnippet

snippet ctxd "context with cancel"
ctx, cancel := context.WithTimeout(context.Background(), ${1:time.Second})
defer cancel()${0:${VISUAL}}
endsnippet

snippet timeex "time exammple"
time.Date(2000, 1, 2, 3, 4, 5, 0, time.UTC)${0:${VISUAL}}
endsnippet

snippet timeexs "time exammple as string"
"2000-01-02T03:04:05.00Z"${0:${VISUAL}}
endsnippet

snippet herr "handle error"
func (d *impl) handleError(err error) error {
	${0:${VISUAL}}
	return err
}
endsnippet

snippet cli "urfave cli snippet"
app := cli.NewApp()
app.Name = "${1:name}"
app.Usage = "${2:useage}"
app.Flags = []cli.Flag{
	cli.StringFlag{
		Name:  "${3:flag}, ${4:f}",
		Usage: "usage",
	},
}
app.Action = func(c *cli.Context) error {
	fmt.Println("Hello friend!")
	return nil
}

err := app.Run(os.Args)
if err != nil {
	log.Fatal(err)
}
endsnippet


snippet enum "go enumer"
//go:generate enumer -type=${1:Type} -transform=${2:kebab|snake} -output=${4:output}_enumer.go -trimprefix=$1 ${3:-text|-json|-sql|-yaml}
type $1 uint8

const (
	_ $1 = iota
	${0:${VISUAL}}
)
endsnippet

snippet errch "err chan"
errCh :=  make(chan error, 1)
${0:${VISUAL}}
endsnippet

snippet makech "make chan"
${1:val}Ch :=  make(chan ${2:string}, ${3:0})
${0:${VISUAL}}
endsnippet

snippet mainsc "for programming contest"
import (
	"bufio"
	"os"
)

func main() {
	sc := bufio.NewScanner(os.Stdin)
	${0:${VISUAL}}
}

func toI(s string) int {
	i, err := strconv.Atoi(s)
	if err != nil {
		panic(err)
	}
	return i
}
endsnippet


snippet ffm "mark logging"
fmt.Printf("DEBUG =========%s=========\n", "${1:Hello}")
${0:${VISUAL}}
endsnippet

# shorthand variable declaration
snippet : "v := value"
${1} := ${0}
endsnippet

# append assignment
snippet ap= "a = append(a, value)"
${1:slice} = append($1, ${0:value})
endsnippet

# case
snippet case "case ...:"
case ${1:value}:
	${0:${VISUAL}}
endsnippet

# constant
snippet con "const XXX Type = ..."
const ${1:NAME} ${2:Type} = ${0:0}
endsnippet

# constants
snippet cons "const ( ... )"
const (
	${1:NAME} ${2:Type} = ${3:value}
	${0}
)
endsnippet

# default case
snippet default "default: ..."
default:
	${0:${VISUAL}}
endsnippet

# defer
snippet df "defer someFunction()"
defer ${1:func}(${2})
${0}
endsnippet

snippet def "defer func() { ... }"
defer func() {
	${0:${VISUAL}}
}()
endsnippet

# defer recover
snippet defr
defer func() {
	if err := recover(); err != nil {
		${0:${VISUAL}}
	}
}()
endsnippet

# if condition
snippet if "if ... { ... }"
if ${1:condition} {
	${0:${VISUAL}}
}
endsnippet

# else snippet
snippet else
else {
	${0:${VISUAL}}
}
endsnippet

# if inline error
snippet ife "If with inline error"
if err := ${1:condition}; err != nil {
	${0:${VISUAL}}
}
endsnippet

# error snippet
snippet errn "Error return" !b
if err != nil {
	return err
}
${0}
endsnippet

# error log snippet
snippet errl "Error with log.Fatal(err)" !b
if err != nil {
	log.Fatal(err)
}
${0}
endsnippet

# error multiple return
snippet errn, "Error return with two return values" !b
if err != nil {
	return ${1:nil}, ${2:err}
}
${0}
endsnippet

# error panic
snippet errp "Error panic" !b
if err != nil {
	panic(${1})
}
${0}
endsnippet

# error test
snippet errt "Error test fatal " !b
if err != nil {
	t.Fatal(err)
}
${0}
endsnippet

# fallthrough
snippet ft "fallthrough"
fallthrough
endsnippet

# for loop
snippet for "for ... { ... }"
for ${1} {
	${0:${VISUAL}}
}
endsnippet

# for integer loop
snippet fori "for 0..N-1 { ... }"
for ${1:i} := 0; $1 < ${2:N}; $1++ {
	${0:${VISUAL}}
}
endsnippet

# for range loop
snippet forr "for k, v := range items { ... }"
for ${2:k}, ${3:v} := range ${1} {
	${0:${VISUAL}}
}
endsnippet

snippet forsel "for select"
for {
	select {
		case ${2:${1:result} := }<- ${3:channel}:
			${0}
	}
}
endsnippet

snippet selc "select case" !b
case ${1:${2:var} := }<-${3:channel}:
  ${0}
endsnippet

# Fmt Printf debug
snippet ff "fmt.Printf(...)"
fmt.Printf("DEBUG $1 = %+v\n", ${1:${VISUAL}})
endsnippet

# Fmt Printf debug with hash
snippet ffh "fmt.Printf(#...) hash"
fmt.Printf("DEBUG $1 = %#v\n", ${1:${VISUAL}})
endsnippet

# Fmt Println debug
snippet fn "fmt.Println(...)"
fmt.Println("DEBUG ${1:${VISUAL}}")
endsnippet

# select
snippet select "select { case a := <-chan: ... }"
select {
case ${1:v1} := <-${2:chan1}
	${0}
}
endsnippet

# struct
snippet st "type T struct { ... }"
type ${1:Type} struct {
	${0}
}
endsnippet

# switch
snippet switch "switch x { ... }"
switch ${1:var} {
case ${2:value1}:
	${0}
}
endsnippet

snippet tswitch "type switch x { ... }"
switch ${2:$1 := }${1:v}.(type) {
	${0}
}
endsnippet

# sprintf
snippet sp "fmt.Sprintf(...)"
fmt.Sprintf("%${1:s}", ${2:var})
endsnippet

# goroutine named function
snippet go "go someFunc(...)"
go ${1:funcName}(${0})
endsnippet

# goroutine anonymous function
snippet gof "go func() { ... }()"
go func() {
	${1:${VISUAL}}
}()
${0}
endsnippet

snippet hf "http.HandlerFunc"
func ${1:handler}(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintf(w, "hello world")}
}
endsnippet

snippet hhf "mux.HandleFunc" !b
${1:http}.HandleFunc("${2:/}", func(w http.ResponseWriter, r *http.Request) {
	${0:fmt.Fprintf(w, "hello world")}
})
endsnippet

# quick test server
snippet tsrv "httptest.NewServer"
ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, ${1:`response`})
}))
defer ts.Close()

${0:someUrl} = ts.URL
endsnippet

snippet example "func ExampleXYZ() { ... }"
func Example${1:Method}() {
	${0:${VISUAL}}
	// Output:
}
endsnippet

snippet benchmark "func BenchmarkXYZ(b *testing.B) { ... }"
func Benchmark${1:Method}(b *testing.B) {
	for i := 0; i < b.N; i++ {
		${0:${VISUAL}}
	}
}
endsnippet

# variable declaration
snippet var "var x Type [= ...]"
var ${1:x} ${2:Type}${3: = ${0:value}}
endsnippet

# variables declaration
snippet vars "var ( ... )"
var (
	${1:x} ${2:Type}${3: = ${0:value}}
)
endsnippet

snippet reqerr "req error"
require.NoError(t, err)${0:${VISUAL}}
endsnippet


snippet aserr "req error"
assert.Equal(t, tt.wantErr, err != nil, err)${0:${VISUAL}}
endsnippet

snippet log "info logging"
logger.L().Info(${1:"message"})${0:${VISUAL}}
endsnippet

snippet logc "info logging"
logger.C(ctx).Info(${1:"message"})${0:${VISUAL}}
endsnippet

snippet dateex "DataTimeExample"
2000-01-01T00:00:00Z
endsnippet

snippet dateexstr "DataTimeExample"
"2000-01-01T00:00:00Z"
endsnippet

snippet dateexgo "DataTimeExample as go time"
time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)
endsnippet

snippet freeport "get free port"
func GetFreePortT(t *testing.T) (int) {
	t.Helper()
	port, err := GetFreePort()
	if err != nil {
		t.Fatal(err)
	}
	return port
}
func GetFreePort() (int, error) {
	addr, err := net.ResolveTCPAddr("tcp", "localhost:0")
	if err != nil {
		return 0, err
	}

	l, err := net.ListenTCP("tcp", addr)
	if err != nil {
		return 0, err
	}
	defer l.Close()
	return l.Addr().(*net.TCPAddr).Port, nil
}
${0:${VISUAL}}
endsnippet


snippet setnow "Set Now Fixture"
func SetNow(t *testing.T, fix time.Time) {
	org := timeNow
	timeNow = func() time.Time { return fix }
	t.Cleanup(func() {
		timeNow = org
	})
}
${0:${VISUAL}}
endsnippet

snippet testm "Test Main"
func TestMain(m *testing.M) {
	${0:${VISUAL}}
	os.Exit(m.Run())
}
endsnippet

